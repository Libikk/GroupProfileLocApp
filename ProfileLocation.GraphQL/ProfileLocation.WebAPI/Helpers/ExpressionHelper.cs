// <copyright file="ExpressionHelper.cs" company="Victor Saly">
// Copyright (c) Victor Saly. All rights reserved.
// </copyright>
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using ProfileLocation.Domain.ORM.Enums;
using ProfileLocation.Domain.ORM.Models.Input;
using ProfileLocation.WebAPI.Models.GraphQL.Shared;

namespace ProfileLocation.WebAPI.Helpers
{
    public static class ExpressionHelper
    {
        private static readonly MethodInfo EnumerableAnyMethod = typeof(Enumerable).GetMethods().First(w => w.Name == "Any" && w.GetParameters().Count() == 2);
        private static readonly MethodInfo EnumerableContainsMethod = typeof(Enumerable).GetMethods().First(w => w.Name == "Contains" && w.GetParameters().Count() == 2);
        private static readonly MethodInfo StringStartsWithMethod = typeof(string).GetMethod("StartsWith", new[] { typeof(string) });
        private static readonly MethodInfo StringEndsWithMethod = typeof(string).GetMethod("EndsWith", new[] { typeof(string) });
        private static readonly MethodInfo StringContainsMethod = typeof(string).GetMethod("Contains", new[] { typeof(string) });

        public static Expression GetValueExpression(Dictionary<string, object> context, ParameterExpression paramEx, MemberExpression parentParam = null)
        {
            Expression ret = null;

            foreach (var ctxPair in context)
            {
                var propName = Char.ToUpperInvariant(ctxPair.Key[0]) + ctxPair.Key.Substring(1);
                var propertyAccessor = Expression.PropertyOrField((Expression) parentParam ?? paramEx, propName);
                var propType = Nullable.GetUnderlyingType(propertyAccessor.Type) ?? propertyAccessor.Type;

                if (ctxPair.Value is IEnumerable<object> localFieldConditions)
                {
                    var fieldConditions = localFieldConditions.Cast<IDictionary<string, object>>();

                    foreach (var condition in fieldConditions)
                    {
                        var conditionOperator = ExpressionType.OrElse;
                        if (condition.ContainsKey("operator"))
                        {
                            conditionOperator = condition["operator"].ToString() == "AND" ? ExpressionType.AndAlso : ExpressionType.OrElse;
                            condition.Remove("operator");
                        }

                        if (propertyAccessor.Type == typeof(string))
                        {
                            var stringSearch = condition as Dictionary<string, object>;
                            var searchMethod = stringSearch["method"] as string;
                            string[] searchValues;
                            if (stringSearch["values"] == null)
                            {
                                searchValues = new string[] {null};
                            }
                            else
                            {
                                searchValues = stringSearch["values"] is string s ? new[] {s} : ((IEnumerable<object>) stringSearch["values"]).Cast<string>().ToArray();
                            }


                            if (searchMethod == StringSearchMethodEnumType.Equals || searchMethod == StringSearchMethodEnumType.NotEqual)
                            {
                                var valListExpression = Expression.Constant(searchValues);
                                Expression containsExpression = Expression.Call(EnumerableContainsMethod.MakeGenericMethod(typeof(string)), valListExpression, propertyAccessor);
                                var valueEqualExpression = searchMethod == StringSearchMethodEnumType.Equals ? containsExpression : Expression.Not(containsExpression);
                                ret = BuildExpression(ret, valueEqualExpression, conditionOperator);
                            }
                            else
                            {
                                var searchOrBinaryExpressions = new List<Expression>();

                                foreach (var searchValue in searchValues)
                                {
                                    var val = Expression.Constant(searchValue);
                                    switch (searchMethod)
                                    {
                                        case StringSearchMethodEnumType.Contains:
                                            searchOrBinaryExpressions.Add(Expression.Call(propertyAccessor, StringContainsMethod, val));
                                            break;
                                        case StringSearchMethodEnumType.StartsWith:
                                            searchOrBinaryExpressions.Add(Expression.Call(propertyAccessor, StringStartsWithMethod, val));
                                            break;
                                        case StringSearchMethodEnumType.EndsWith:
                                            searchOrBinaryExpressions.Add(Expression.Call(propertyAccessor, StringEndsWithMethod, val));
                                            break;
                                        default:
                                            throw new ArgumentException($"Method type {searchMethod} for field type {propertyAccessor.Type} is not supported!");
                                    }
                                }

                                ret = BuildExpression(ret, searchOrBinaryExpressions.Aggregate(Expression.OrElse), conditionOperator);
                            }
                        }
                        else if (propType == typeof(bool))
                        {
                            var boolSearch = condition as Dictionary<string, object>;
                            var value = (bool) boolSearch["value"];

                            ret = BuildExpression(ret, Expression.Equal(propertyAccessor, Expression.Constant(value, propertyAccessor.Type)), conditionOperator);
                        }
                        else if (propType == typeof(DateTime))
                        {
                            var range = condition as Dictionary<string, object>;
                            var from = range.ContainsKey("from") ? (DateTime?) range["from"] : null;
                            var to = range.ContainsKey("to") ? (DateTime?) range["to"] : null;

                            if (!(from.HasValue || to.HasValue)) throw new Exception("Date range must have at least a to or from date!");

                            if (from.HasValue && to.HasValue)
                            {
                                ret = BuildExpression(ret,
                                    Expression.AndAlso(
                                        Expression.GreaterThan(propertyAccessor, Expression.Constant(from, propertyAccessor.Type)),
                                        Expression.LessThan(propertyAccessor, Expression.Constant(to, propertyAccessor.Type))),
                                    conditionOperator);
                            }
                            else
                            {
                                ret = BuildExpression(ret,
                                    from.HasValue ? Expression.GreaterThan(propertyAccessor, Expression.Constant(from, propertyAccessor.Type)) : Expression.LessThan(propertyAccessor, Expression.Constant(to, propertyAccessor.Type)),
                                    conditionOperator);
                            }
                        }
                        else if (propType == typeof(int) || propType == typeof(long) || propType == typeof(short) || propType == typeof(byte) ||
                                 propType == typeof(double))
                        {
                            var integerSearch = condition as Dictionary<string, object>;
                            var searchMethod = integerSearch["method"] as string;
                            if (!integerSearch.ContainsKey("values")) throw new Exception("Must specify values");
                            var values = (IList<object>) integerSearch["values"];

                            var typeDescriptor = TypeDescriptor.GetConverter(propertyAccessor.Type);

                            switch (searchMethod)
                            {
                                case NumberSearchMethodEnumType.Range:
                                    var min = values.Take(1).First();
                                    var max = values.Skip(1).FirstOrDefault();

                                    if (min == null && max == null) throw new ArgumentNullException("values", "Must have at least a min or max in index 1 or 2 that is not null!");

                                    if (min != null && max != null)
                                    {
                                        var exp =
                                            Expression.And(
                                                Expression.GreaterThanOrEqual(propertyAccessor, Expression.Constant(typeDescriptor.ConvertFrom(min?.ToString()))),
                                                Expression.LessThanOrEqual(propertyAccessor, Expression.Constant(typeDescriptor.ConvertFrom(max?.ToString()))));
                                        ret = BuildExpression(ret, exp, conditionOperator);
                                    }
                                    else
                                    {
                                        var exp = min != null ? Expression.GreaterThanOrEqual(propertyAccessor, Expression.Constant(typeDescriptor.ConvertFrom(min?.ToString()))) : Expression.LessThanOrEqual(propertyAccessor, Expression.Constant(typeDescriptor.ConvertFrom(max?.ToString())));

                                        ret = BuildExpression(ret, exp, conditionOperator);
                                    }

                                    break;
                                case NumberSearchMethodEnumType.Equal:
                                case NumberSearchMethodEnumType.NotEqual:
                                    if (values.Any(a => a == null)) throw new ArgumentNullException("values", $"Cannot have null value when method is {searchMethod}");

                                    IList convertedValues = (IList) Activator.CreateInstance(typeof(List<>).MakeGenericType(propertyAccessor.Type));
                                    foreach (var val in ((IEnumerable) integerSearch["values"]))
                                    {
                                        convertedValues.Add(typeDescriptor.ConvertFrom(val?.ToString()));
                                    }

                                    var valListExpression = Expression.Constant(convertedValues);
                                    Expression containsExpression = Expression.Call(EnumerableContainsMethod.MakeGenericMethod(propertyAccessor.Type), valListExpression, propertyAccessor);
                                    var eqExp = searchMethod == NumberSearchMethodEnumType.NotEqual ? Expression.Not(containsExpression) : containsExpression;
                                    ret = BuildExpression(ret, eqExp, conditionOperator);

                                    break;
                                default:
                                    throw new ArgumentException($"Method type {searchMethod} for field type {propertyAccessor.Type} is not supported!");
                            }
                        }
                        else if (typeof(IEnumerable).IsAssignableFrom(propertyAccessor.Type)) //List
                        {
                            var subParameter = Expression.Parameter(propertyAccessor.Type.GenericTypeArguments[0], ctxPair.Key);
                            var listBinary = GetValueExpression(condition as Dictionary<string, object>, subParameter);
                            var anyLambda = Expression.Lambda(listBinary, subParameter);

                            var anyExpression = Expression.Call(EnumerableAnyMethod.MakeGenericMethod(propertyAccessor.Type.GenericTypeArguments[0]), propertyAccessor, anyLambda);
                            ret = BuildExpression(ret, anyExpression, conditionOperator);
                        }
                        else if (propType == typeof(Guid))
                        {
                            var guidSearch = condition as Dictionary<string, object>;
                            var value = (Guid) guidSearch["value"];

                            ret = BuildExpression(ret, Expression.Equal(propertyAccessor, Expression.Constant(value, propertyAccessor.Type)), conditionOperator);
                        }
                        else
                        {
                            var listExpression = GetValueExpression(condition as Dictionary<string, object>, paramEx, propertyAccessor);
                            ret = BuildExpression(ret, listExpression, conditionOperator);
                        }
                    }
                }
                else
                {
                    var listExpression = GetValueExpression(ctxPair.Value as Dictionary<string, object>, paramEx, propertyAccessor);
                    ret = BuildExpression(ret, listExpression, ExpressionType.AndAlso);
                }
            }


            Debug.WriteLine(ret.ToString());
            return ret;
        }

        public static IQueryable<TEntity> SortQuery<TEntity>(this IQueryable<TEntity> query, IList<SortOrderModel> sortOrders)
        {
            var paramExpression = Expression.Parameter(typeof(TEntity), "o");
            IOrderedQueryable<TEntity> sortedQuery = null;

            for (int i = 0; i < sortOrders.Count; i++)
            {
                var order = sortOrders[i];
                var propertyExpression = Expression.PropertyOrField(paramExpression, order.Field);
                var convertExpression = Expression.Convert(propertyExpression, typeof(object));

                var lambdaExpression = Expression.Lambda<Func<TEntity, object>>(convertExpression, paramExpression);

                if (order.Direction == SortDirectionEnum.ASC)
                {
                    sortedQuery = i == 0 ? query.OrderBy(lambdaExpression) : sortedQuery.ThenBy(lambdaExpression);
                }
                else
                {
                    sortedQuery = i == 0 ? query.OrderByDescending(lambdaExpression) : sortedQuery.ThenByDescending(lambdaExpression);
                }
            }

            return sortedQuery.AsQueryable();
        }

        private static Expression BuildExpression(Expression previous, Expression newExpression, ExpressionType conditionOperator)
        {
            if (conditionOperator != ExpressionType.AndAlso && conditionOperator != ExpressionType.OrElse)
                throw new Exception($"{conditionOperator} is not supported");

            if (previous == null)
                return newExpression;

            switch (conditionOperator)
            {
                case ExpressionType.AndAlso:
                    return Expression.AndAlso(previous, newExpression);
                case ExpressionType.OrElse:
                    return Expression.OrElse(previous, newExpression);
                default:
                    throw new Exception($"{conditionOperator} is not supported");
            }
        }
    }
}
