// <copyright file="GraphQLUtilities.cs" company="Victor Saly">
// Copyright (c) Victor Saly. All rights reserved.
// </copyright>
// <auto-generated />
using GraphQL.Resolvers;
using GraphQL.Types;
using GraphQL.Utilities;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using NLog;

namespace ProfileLocation.WebAPI.Utils
{
    public static class GraphQLUtilities
    {
        private static ILogger _logger = LogManager.GetCurrentClassLogger();

        public static Dictionary<Type, Type> _registeredQLOutputTypes = new Dictionary<Type, Type>();
        public static Dictionary<Type, (Type QLType, string QLName)> _registeredQLEnumTypes = new Dictionary<Type, (Type QLType, string QLName)>();
        public static Dictionary<Type, (Type QLType, string QLName)> _registeredQLInputTypes = new Dictionary<Type, (Type QLType, string QLName)>();

        /// <summary>
        /// Parses argument (Dictionary string,object) into populated type based on parameterInfo
        /// </summary>
        /// <param name="paramInfo"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static object ParseObjectValueFromQL(ParameterInfo paramInfo, object value)
        {
            if (value is Dictionary<string, object> dictionary)
            {
                var json = JsonConvert.SerializeObject(dictionary, Newtonsoft.Json.Formatting.Indented);
                return JsonConvert.DeserializeObject(json, paramInfo.ParameterType);
            }
            else
            {
                return value;
            }
        }

        /// <summary>
        /// Generates and registers in DI a input QLType based on a class/type
        /// </summary>
        /// <param name="inputParameterType"></param>
        /// <param name="services"></param>
        /// <returns></returns>
        public static Type GenerateQlInputType(Type inputParameterType, IServiceCollection services, out string qlTypeName)
        {
            Type ret;

            var builtInQLType = GraphTypeTypeRegistry.Get(inputParameterType);
            if (builtInQLType != null)
            {
                qlTypeName = builtInQLType.Name;
                return builtInQLType;
            }

            if (_registeredQLInputTypes.ContainsKey(inputParameterType))
            {
                var registeredType = _registeredQLInputTypes[inputParameterType];
                qlTypeName = registeredType.QLName;
                return registeredType.QLType;
            }

            var underlyingType = Nullable.GetUnderlyingType(inputParameterType) ?? inputParameterType;

            if (underlyingType.IsPrimitive || underlyingType == typeof(string) || underlyingType == typeof(decimal))
            {
                qlTypeName = underlyingType.Name;
                ret = GraphTypeTypeRegistry.Get(underlyingType);
            }
            else
            {
                string modelName;
                Type qlInputType;

                if (typeof(IEnumerable).IsAssignableFrom(underlyingType))
                {
                    //Is a list or array
                    var listType = underlyingType.IsArray ? underlyingType.GetElementType() : underlyingType.GenericTypeArguments[0];
                    var listQLType = GenerateQlInputType(listType, services, out var listQLTypeName);

                    qlInputType = typeof(ListGraphType<>).MakeGenericType(listQLType);

                    modelName = $"IEnumerable{listQLTypeName}";

                    services.AddTransient(qlInputType, ctx =>
                    {
                        var outputQLModel = (ListGraphType)Activator.CreateInstance(qlInputType);
                        outputQLModel.Name = modelName;
                        return outputQLModel;
                    });
                    _logger.Debug($"QLInputTypeRegistered: {modelName} for {underlyingType.Name}");
                }
                else if (underlyingType.IsEnum)
                {
                    qlInputType = GetQLEnumType(underlyingType, services, out modelName);
                }
                else
                {
                    qlInputType = typeof(InputObjectGraphType<>).MakeGenericType(underlyingType);
                    modelName = inputParameterType.Name;     
                    var modelFields = new List<FieldType>();

                    foreach (var inputModelProperty in inputParameterType.GetProperties())
                    {
                        if (inputModelProperty.GetSetMethod()?.IsPrivate ?? true) continue;

                        var field = new FieldType();
                        field.Name = inputModelProperty.Name;

                        var underlyingPropType = Nullable.GetUnderlyingType(inputModelProperty.PropertyType) ?? inputModelProperty.PropertyType;
                        var fieldType = GenerateQlInputType(underlyingPropType, services, out _);

                        field.Type = fieldType;
                        modelFields.Add(field);
                    }

                    services.AddTransient(qlInputType, ctx =>
                    {
                        var outputQLModel = (IComplexGraphType)Activator.CreateInstance(qlInputType);
                        outputQLModel.Name = modelName;
                        modelFields.ForEach(f => outputQLModel.AddField(f));
                        return outputQLModel;
                    });
                    _logger.Debug($"QLInputTypeRegistered: {modelName}:{string.Join(", ", modelFields.Select(s => $"{s.Name}:[{s.Type}]"))}");
                }

                _registeredQLInputTypes[inputParameterType] = (qlInputType, modelName);
                
                qlTypeName = modelName;
                ret = qlInputType;
            }

            Debug.Assert(ret != null);

            return ret;
        }

        /// <summary>
        /// Generates query argument for QL based on type and method parameterinfo
        /// </summary>
        /// <param name="inputParam"></param>
        /// <param name="inputType"></param>
        /// <returns></returns>
        public static QueryArgument GetQLInputQueryArgument(ParameterInfo inputParam, Type inputType, string description)
        {
            QueryArgument argument;
            var isNullableType = Nullable.GetUnderlyingType(inputParam.ParameterType) != null;

            if (inputParam.HasDefaultValue)
            {
                var qlInputType = inputType;
                argument = new QueryArgument(qlInputType);
                argument.DefaultValue = inputParam.DefaultValue;
            }
            else if (isNullableType)
            {
                var qlInputType = inputType;
                argument = new QueryArgument(qlInputType);
            }
            else
            {
                var qlInputType = typeof(NonNullGraphType<>).MakeGenericType(inputType);
                argument = new QueryArgument(qlInputType);
            }

            argument.Name = inputParam.Name;
            argument.Description = description;
            return argument;
        }

        /// <summary>
        /// Returns default value based on method parameter info
        /// </summary>
        /// <param name="parameter"></param>
        /// <returns></returns>
        public static object GetParameterDefaultValue(ParameterInfo parameter)
        {
            if (parameter.IsOptional)
            {
                return parameter.DefaultValue;
            }
            else
            {
                if (parameter.ParameterType.IsValueType)
                {
                    return Activator.CreateInstance(parameter.ParameterType);
                }
            }

            return null;
        }

        /// <summary>
        /// Generates and registers QL output type based on type
        /// </summary>
        /// <param name="outputType"></param>
        /// <param name="services"></param>
        /// <returns></returns>
        public static Type GenerateQLOutputType(Type outputType, IServiceCollection services)
        {
            //Check built in library if output type exists
            var builtInQlType = GraphTypeTypeRegistry.Get(outputType);
            if (builtInQlType != null) return builtInQlType;


            var isList = typeof(IEnumerable).IsAssignableFrom(outputType);

            //Check if its already registered
            if (!_registeredQLOutputTypes.ContainsKey(outputType))
            {
                Type model;


                if (isList)
                {
                    //Its a list/array so recurse and registers all sub types, when returned registers and create the list of type
                    var listType = outputType.IsArray ? outputType.GetElementType() : outputType.GenericTypeArguments[0];
                    var listQLType = GenerateQLOutputType(listType, services);
                    model = typeof(ListGraphType<>).MakeGenericType(listQLType);

                    if (_registeredQLOutputTypes.ContainsKey(model))
                    {
                        return model;
                    }

                    services.AddTransient(model, ctx =>
                    {
                        var outputQLListModel = (IComplexGraphType)Activator.CreateInstance(model);
                        outputQLListModel.Name = $"ListOf" + listType.Name;
                        return outputQLListModel;
                    });
                }
                else if (outputType.IsEnum)
                {
                    var underlyingType = Nullable.GetUnderlyingType(outputType) ?? outputType;
                    model = GetQLEnumType(underlyingType, services, out _);
                }
                else
                {
                    model = typeof(ObjectGraphType<>).MakeGenericType(outputType);
                    var modelName = outputType.Name;
                    var modelReturnType = outputType;

                    var modelFields = new List<FieldType>();

                    foreach (var outputModelProperty in modelReturnType.GetProperties())
                    {
                        if (outputModelProperty.GetSetMethod()?.IsPrivate ?? true) continue;
                        
                        var field = new FieldType();
                        field.Name = outputModelProperty.Name;

                        var underlyingType = Nullable.GetUnderlyingType(outputModelProperty.PropertyType) ?? outputModelProperty.PropertyType;

                        //Get the property output type, recurse to find
                        var fieldType = GenerateQLOutputType(underlyingType, services);

                        field.Type = fieldType;
                        field.Resolver = new FuncFieldResolver<object>(context => outputModelProperty.GetValue(context.Source));
                        modelFields.Add(field);
                    }
                    _logger.Debug($"QLOutputTypeRegistered: {modelName}:{string.Join(", ", modelFields.Select(s => $"{s.Name}:[{s.Type}]"))}");

                    services.AddTransient(model, ctx =>
                    {
                        var outputQLModel = (IComplexGraphType)Activator.CreateInstance(model);
                        outputQLModel.Name = modelName;
                        modelFields.ForEach(f => outputQLModel.AddField(f));
                        return outputQLModel;
                    });
                }

                //Register the created type in internal lookup
                _registeredQLOutputTypes[outputType] = model;
            }

            return _registeredQLOutputTypes[outputType];
        }

        private static Type GetQLEnumType(Type enumType, IServiceCollection services, out string qlEnumTypeName)
        {
            if (_registeredQLEnumTypes.TryGetValue(enumType, out var qlType))
            {
                qlEnumTypeName = qlType.QLName;
                return qlType.QLType;
            }

            //Is enum
            var qlEnumType = typeof(EnumerationGraphType<>).MakeGenericType(enumType);
            var modelName = $"{enumType.Name + "EnumQLType"}";

            services.AddTransient(qlEnumType, ctx =>
            {
                var outputQLModel = (EnumerationGraphType)Activator.CreateInstance(qlEnumType);
                outputQLModel.Name = modelName;
                return outputQLModel;
            });
            _logger.Debug($"EnumQLType Registered: {modelName} for {enumType.Name}");

            _registeredQLEnumTypes[enumType] = (qlEnumType, modelName);

            qlEnumTypeName = modelName;
            return qlEnumType;
        }
    }    
}
